# 第6章 miniKanren

By Jack Moffitt

在花费了数十年来告诉计算机如何做事之后，我发现只有逻辑编程能够让我脱离苦海。
因为在使用逻辑编程的时候，你只需要描述问题的关系及其约束，计算机就会自动得出满足问题的解。

我还记得我第一次意识到逻辑编程是如此的与众不同的场景。
那是在一个会议上，当时Dan Friedman和William Byrd正在介绍一个用miniKanren编写的小型语言解释器。
他们首先展示了它可以计算一些简单的数学公式，并得能够得出正确答案。
之后就像神奇的巫术一样，他们用这个解释器反向执行了程序，并且得到原来的问题。

我们能接触到的最接近真正意义的魔法可能就是逻辑编程了。
当用逻辑来编程的时候，我并不需要担心每一细节的实现。
就像哈利波特里一样，我只是需要说“星星点灯”——然后灯就亮了。

当前有很多对miniKanren<sup>[1]</sup>的实现。
在这一章里，我们将对内嵌在Clojure中的miniKanren——core.logic进行探索。
和Prelog类似，因为对规则和约束的注重，miniKanren对于某些问题可以迎刃而解，但对于另外一些问题则没有什么好办法去解决。
而core.logic作为一个良好的实用工具，它能够在神秘的逻辑的领域和我们每天的日常工作之间架起一道方便的桥梁。

[1]: http://minikanren.org

## 第一天：代码的一致性匹配

其实只需要3天就能够让你学会并且熟练地使用逻辑。
而由于core.logic是内嵌在Clojure里的，所以如果你有函数式编程的经验，会让更加的轻松。

第一天里，我们将会了解一些逻辑的基本知识。
之后会通过一个充满因子的数据库，来了解core.logic是怎样使用它们的。
最后我们还会讲讲逻辑判断相关的知识。

在第二天，我们将会对头一天的内容进行补充，例如：
模式匹配以及一些语法糖。
之后我们会关注与散列图相关的知识。

最后一天，我们会通过学习有限域，并回顾前两天的知识。
相信到了这个时候，你也能够处理一些复杂的问题了。

虽然时间短暂，但是在学习之余，你还是可以继续探索逻辑编程，并且将其带入到自己的工作之中。

### 安装core.logic

要安装core.logic，首先需要安装Java虚拟机（JVM）以及Leiningen——一个可以让你远离繁重地管理获取各种Java库地解决方案的构建工具。

关于JVM，你可以在你的系统包管理程序里或者通过Oracle的Java下载页面<sup>[2]</sup>获取到它。
至于Leiningen以及它在各种操作系统上的安装说明，则可以从它的官方主页<sup>[3]</sup>得到相应的信息。

[2]: https://www.oracle.com/technetwork/java/javase/downloads/index.html

[3]: https://leiningen.org/

当所有的准备工作已经做好之后，你可以用命令`lein new`来创建一个新项目：

```shell
$ lein new logical
Generating a project called logical based on the 'default' template. To see other templates (app, lein plugin, etc), try `lein help new`.
```

这个命令会在`logical`目录下创建一个项目的基本结构。
我们还需要在项目文件`project.clj`里面添加一些引用，才能够在项目中使用core.logic。
修改之后的`logical/project.clj`文件应该是这样的：

**minikanren/logical/project.clj**
```shell
(defproject logical "0.1.0-SNAPSHOT" 
  :dependencies [[org.clojure/clojure "1.5.1"]
                 [org.clojure/core.logic "0.8.5"]])
```

现在，你就能够在项目目录里使用Clojure REPL并且加载core.logic了。

```shell
$ lein repl
nREPL server started on port 48235 on host 127.0.0.1 
REPL-y 0.3.0
Clojure 1.5.1
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=> (use 'clojure.core.logic)
WARNING: == already refers to: #'clojure.core/== in namespace: user, being
  replaced by: #'clojure.core.logic/== 
nil
user=>
```

注意到那个警告了吗？
这并不是件坏事，恰恰相反，它表明有一个core.logic的符号替换掉了默认值。
逻辑就在你的指尖徘徊！

### 目标一定要成功

就像是一个只包含规则和少量数字的数独，或者是一个只能看到部分图片及其形状的拼图游戏一样，逻辑编程就像是一个只知道一部分信息的谜题，而它的解就是去找到那些剩下的信息。

简单来说，用逻辑来编程就是：
提供谜题的初始值以及相应的规则，之后core.logic会去做整个求解过程，并且解出所有可能的解。

让我们来看一个简单的逻辑程序吧。
为了让我们的探索过程更简单，这里将会用REPL来编写。
试试下面的代码：

```Clojure
user=> (run* [q] (== q 1))
(1)
```

虽然这段代码写出的逻辑程序一看就非常简单，但还是有很多点可以谈及的。

`run*`用来启动一个逻辑程序，并且返回它的所有解。
`q`叫做逻辑变量。
当逻辑变量被创建的时候，它们没有绑定在任何的值上。
正是因为它们没有值，所以它们可以代表任何的东西。
在我们的例子里，`q`的值是解的集合。
至于为什么`q`会成为最常用的逻辑变量名，或许是因为其来自于单词“查询（query）”。

关于逻辑变量的一个直观理解可以是：
在数独里每一个小块都可以当作为一个逻辑变量，其中一些小块是空的（*自由的，未绑定的*），而另外一些则被填上了值（*已绑定的*）。

在我们的逻辑程序里，还包含了一条表达式——`(==q 1)`，这并不是你曾经用到过的相等判定。
在core.logic里，`==`被称为一致性函数。
这个表达式代表的是，尝试让数字`1`和逻辑变量`q`保持一致。

与模式匹配相似，一致性是你让程序在假设可能的情况下，尝试让左右两边值相同。
当左右两边用普通的相等判定得出解的时候，未绑定的逻辑变量将会被绑定到这个值上。
在我们的例子里：
`q`会被绑定到数字`1`上，而因为没有其他的约束条件，也就得出了这个程序的解。
现在可能看起来比较奇怪，当我们看过更多的例子之后，你就能更清晰的感受到发生了什么。

在逻辑程序里，表达式被称作目标。
它们返回**成功**或**失败**，而不是**真**或**假**。
当成功的时候，可能会找到多个不同的解法，而如果没有任何解，则返回失败。
这就引申到来我们例子里的最后一部分：结果。

就像之前说的`run*`将会返回所有目标结果为成功的`q`的值。
在我们的例子中：
`q`和`1`绑定之后与数字`1`保持一致并且返回成功，因此例子里的结果为`(1)`。
这个结果集也正好是符合条件的唯一一个`q`的绑定。

让我们再来看一个失败的目标：

```Clojure
user=> (run* [q] (== q 1) (== q 2))
()
```

这个程序有2个表达式，每一个表达式都是一个目标。
当一个程序有多个目标的时候，就像其他语言中的`&&`和`and`关键词一样，只有当所有的目标都返回成功的情况下才会返回成功。
在这个例子里，第一个一致性判定会像之前的例子里一样把`q`绑定到数字`1`并返回成功。
而因为`1`并不能和`2`保持一致性，所以第二个一致性判定将会返回失败。
这样，由于没有任何一个`q`的绑定能够同时让两个目标都返回成功，程序的结果集将会为空。

### 使用关系

让我们再来看看这个逻辑方法：

```Clojure
user=> (run* [q] (membero q [1 2 3]))
(1 2 3)
```

`membero`是一个关系。
它的意思是第一个参数是第二个参数所提供的集合里的一员。
因为这也是一个目标，所以它的结果也会是成功或失败，同时当结果为成功时，
会将`q`绑定到相应的值上。在我们这个例子里，成功的返回了值`1`、`2`、`3`。
需要注意的一点是：
我这个例子里我们并没有告诉core.logic怎么解这个问题，只告诉了它关系。

`run*`会返回所有结果为成功的绑定，也就是包含了所有成功值的列表。
在我们这个简单的程序里，可以凭直觉简单地知道答案都是正确的。
这个小技巧，我们以后也能用上。

同样的，你也可以在使用`run`的时候指定需要的结果大小：

```Clojure
user=> (run 2 [q] (membero q [1 2 3]))
(1 2)
```

这个功能是非常有用的，因为在某些情况下，可能会出现满足目标的无数个解。

逻辑编程还有很多神奇的功能藏在夹袋里呢。
让我们来看看如果我们调换了`membero`的参数之后会发生什么：

```Clojure
user=> (run 5 [q] (membero [1 2 3] q))
(([1 2 3] . _0) (_0 [1 2 3] . _1) (_0 _1 [1 2 3] . _2) (_0 _1 _2 [1 2 3] . _3)
(_0 _1 _2 _3 [1 2 3] . _4))
```

我们来仔细看看这个奇妙的答案。
在原来的方法`membero q [1 2 3]`里，我们是想得到集合里面所有的元素。
但是在新的方法`membero [1 2 3] q`里，求得是什么集合包含了元素`[1 2 3]`。
正因为会有无限多种可能的集合包含元素`[1 2 3]`，所有我们要求只取得5个结果。

第一个结果是`(([1 2 3] . _0)`。
其中`.`代表的是列表的构造操作符。
`.`左边的部分是这个列表的第一个元素（头），右边的部分是这个列表的其余部分（尾）。
那个神奇的`_0`代表的是一个未绑定的逻辑变量，在这个例子里它表示列表的尾可以是任何元素。
换句话说，第一个结果说明，对于任何列表，只要它的第一个元素是`[1 2 3]`就能满足目标了。

其他的结果也是类似的，例如第二个结果就表明，对于任何列表，不论第一个元素和最后一个元素是什么，只要它的第二个元素是`[1 2 3]`就满足目标了。

这就像是对于一个已经解出来的数独，求它可能的开始状况一样。
这很酷不是吗？
我还从来没有见过其他的编程语言支持这样反向执行程序的。

> **后缀"o"是什么意思？**
> 
> 在《The Reasoned Schemer》*[FBK05]*这本书里，用上标"o"代表关系。
> 之后在miniKanren和core.logic社区里，也遵循了这一传统。
>
> 当在逻辑程序里混合了标准Clojure代码时，会发现这一个可以表示特定函数的小小视觉提示，会非常的有用。
> 起初可能看起来比较奇怪，之后你会慢慢习惯它的。并且在对其他人解释你的程序的时候会更加的方便。

### 用因子编程

我们之前介绍了core.logic的基本功能，并且发现它会找到并绑定所有能够满足程序目标的`q`。
我们同样也讲解了一个内置的关系——找到集合里的元素——`membero`。
现在，我们来自己写一个关系。

core.logic包含了一个数据库`pldb`，它可以让我们通过一组因子来构建一个简单的关系。
这和传统数据库系统的表是一样的。
比如说：
我们可以创建2个关系分别叫做`mano`和`womano`。
为了达到目的，我们需要使用`db-rel`命令。
它的第一个参数是关系的名称，其他的参数都是占位符。

```Clojure
user=> (use 'clojure.core.logic.pldb)
nil
user=> (db-rel mano x)
#'user/mano
user=> (db-rel womano x)
#'user/womano
```

这样，我们就创建了2个关系。他们都只接受一个参数，并且当这个参数分别是男性（man）和男性（woman）时返回成功。

我们可以通过给数据库里的方法绑定一组因子来构建关系。每个因子都是一个包含关系和它的参数的一个向量。

```Clojure
user=> (def facts
  #_=>   (db
  #_=>     [mano :alan-turing]
  #_=>     [womano :grace-hopper]
  #_=>     [mano :leslie-lamport]
  #_=>     [mano :alonzo-church]
  #_=>     [womano :ada-lovelace]
  #_=>     [womano :barbara-liskov]
  #_=>     [womano :frances-allen]
  #_=>     [mano :john-mccarthy]))
#'user/facts
```

之后，在数据库里查找就很简单了。让我们来试着找出所有的女性（woman）：

```Clojure
user=> (with-db facts
  #_=>   (run* [q] (womano q)))
(:grace-hopper :ada-lovelace :barbara-liskov :frances-allen)
```

`with-db`方法将数据源设置成了数据库关系。
它既支持同时使用若干个数据库，也支持使用单个数据库。
在我们的例子里，当`q`是女性时，会返回成功。
因此，结果是所有的女性成员。

让我们在多加些关系：`vitalo`和`turingo`。
它们分别代表那些人的当前的状态以及什么时候获得的图灵奖：

```Clojure
user=> (db-rel vitalo p s)
#'user/vitalo

user=> (db-rel turingo p y)
#'user/turingo

user=> (def facts
  #_=>   (-> facts
  #_=>       (db-fact vitalo :alan-turing :dead)
  #_=>       (db-fact vitalo :grace-hopper :dead)
  #_=>       (db-fact vitalo :leslie-lamport :alive)
  #_=>       (db-fact vitalo :alonzo-church :dead)
  #_=>       (db-fact vitalo :ada-lovelace :dead)
  #_=>       (db-fact vitalo :barbara-liskov :alive)
  #_=>       (db-fact vitalo :frances-allen :alive)
  #_=>       (db-fact vitalo :john-mccarthy :dead)
  #_=>       (db-fact turingo :leslie-lamport :2013)
  #_=>       (db-fact turingo :barbara-liskov :2008)
  #_=>       (db-fact turingo :frances-allen :2006)
  #_=>       (db-fact turingo :john-mccarthy :1971)))
#'user/facts
```

现在我们有足够多的因子来回答一些有趣的问题了：

```Clojure
user=> (with-db facts
  #_=>   (run* [q]
  #_=>     (womano q)
  #_=>     (vitalo q :alive)))
(:barbara-liskov :frances-allen)
```

这个目标是：所有或者的女性。需要注意的一点是，当一个目标成功，并且将值绑定到逻辑变量`q`之后，满足其他的关系的值也得要满足这个目标。

为了扩展到更复杂的逻辑程序，我们通常需要更多的逻辑变量。我们可以用`fresh`方法来创建一个新的，未绑定的逻辑变量。

```Clojure
  user=> (with-db facts
    #_=>   (run* [q]
❶   #_=>     (fresh [p y]
❷   #_=>       (vitalo p :dead)
❸   #_=>       (turingo p y)
❹   #_=>       (== q [p y]))))
([:john-mccarthy :1971])
```

1. 我们用`fresh`创建了两个未绑定的逻辑变量

2. 将`p`作为参数传给关系`vitalo`会让它被绑定到所有已经去世的人

3. 当`p`已经绑定好之后，我们可以用`turingo`关系来绑定这个人获得图灵奖的年份。
当然，这个人必须得过图灵奖才能满足关系。

4. 最后，我们将`q`绑定到一个包含了人以及年份的向量

因此这个问题可以被表述为：
“那位去世的人获得过图灵奖？”
在逻辑编程里有趣的一点是，目标的顺序并不重要。
所以在这个例子里，我们先绑定了`p`，然后是`y`，最后绑定了`q`，但这只是定义了目标，并不是执行顺序，让我们来看看改变顺序会怎样：

```Clojure
user=> (with-db facts
   #_=>   (run* [q]
   #_=>     (fresh [p y]
   #_=>       (turingo p y)
   #_=>       (== q [p y])
   #_=>       (vitalo p :dead))))
([:john-mccarthy :1971])
```

这次我们改变了目标的顺序，特别是，`q`在`p`被绑定之前就被设置了一致性。
core.logic会在逻辑变量被绑定的时候去替换未绑定的占位符。
或者，就像我们之前看到过的一样，如果那些占位符到最后都没有被绑定，就会显示成`_0`，`_1`之类的。

### 平行宇宙

在逻辑编程里，还有一个宏命令我们没有讲过：`conde`。
之前看到过的`run`，`run*`以及`fresh`都是只有当所有的目标都成功的时候才会返回成功。
这就有点像是其他语言里的`and`或者`&&`。
而`conde`则有点像`or`或`||`。

和`or`类似，当任何一个目标成功时`conde`就会返回成功。
而不同的是，`conde`会独立的返回每一个成功的目标。
就像是在平行宇宙里跑你的程序一样，不同分支的`conde`会跑在一个全新的宇宙里，然后检测到所有可能的成功。
让我们来看个例子：

```Clojure
user=> (run* [q]
  #_=>   (conde
  #_=>     [(== q 1)]
  #_=>     [(== q 2) (== q 3)]
  #_=>     [(== q :abc)]))
(1 :abc)
```

`conde`的每一个分支就是列表中的一个目标。
只有分支的目标成功时，分支才会成功。
而当每一个分支都执行结束之后`conde`返回成功。
在这个例子里：
第一个分支成功的将`q`绑定到了`1`；
在另一个宇宙里的，第二个分支返回失败；
在第三个宇宙里，第三个分支成功的将`q`绑定到`:abc`。
这样，结果就是在各个宇宙中成功绑定`q`的列表。

### 咒语的秘密

在今天早些时候，我们看到了找集合元素的`membero`关系。
在我们学习了`conso`之后，你就能够实现自己的`membero`关系了。

Lisp语言里，列表的构造函数是`cons`。
因此，`conso`毫无意外的与它是表亲关系。
`conso`是用来将一个列表的头和尾合成在一起的。
并且因为它是关系，所以它接受3个参数——和`cons`类似，最后一个参数接受一个逻辑变量来获得列表构造的结果。

```Clojure
user=> (run* [q] (conso :a [:b :c] q))
((:a :b :c))
```

我们也可以获得列表的尾部。

```Clojure
user=> (run* [q] (conso :a q [:a :b :c]))
((:b :c))
```

如果反向执行`conso`，会把列表分解成为它的头和尾。
这个例子里，我们创建了2个逻辑变量来获得列表的头和尾，然后将`q`绑定到结果的向量上。

```Clojure
user=> (run* [q] (fresh [h t] (conso h t [:a :b :c]) (== q [h t])))
([:a (:b :c)])
```

现在，你知道了怎么提取与合并列表，怎么用`conde`对时空进行操作。
所以我们可以创建一个强大的递归关系了。

让我们创建一个和内置的`membero`具有相同功能的关系`insideo`：

```Clojure
  user=> (defn insideo [e l]
    #_=>   (conde
    #_=>     [(fresh [h t]
    #_=>       (conso h t l)
❶   #_=>       (== h e))]
    #_=>     [(fresh [h t]
    #_=>       (conso h t l)
❷   #_=>       (insideo e t))]))
  #'user/insideo
```

1. 第一个分支用`conde`对集合进行分解，并且当集合的头部与传入的值相等时返回成功。

2. 第二个分支将会递归的对集合的尾部调用`insideo`关系。

我们可以用下面的公式来验证`insideo`和我们预期的结果是一样的：

```Clojure
user=> (run* [q] (insideo q [:a :b :c]))
(:a :b :c)
user=> (run 3 [q] (insideo :a q))
((:a . _0) (_0 :a . _1) (_0 _1 :a . _2))
user=> (run* [q] (insideo :d [:a :b :c q]))
(:d)
```

`insideo`也可以正向和反向工作。
并且在最后一个例子里，它甚至能够判断什么元素会让自己成功。

### 第一天我们学到了什么

现在，你已经通过在时间和空间上初步掌握了逻辑。
也知道了你并不需要知道解决方案的每一步，只需要将问题和常量用公式表达出来。

今天我们学到了很多逻辑相关的知识。
有如何用`run*`和`run`来写逻辑程序，还有逻辑变量和一致性是怎么工作的——告诉电脑一些数据和规则之后它会自动的帮你解出答案。
通过这些，我们看到了在其他语言里不存在，只存在于逻辑编程里的第一个特殊用法——`membero`关系的正向和反向执行。

存放因子的数据库可以让我们为逻辑程序创建一些基础的知识库。
随后可以用这个知识库来创建推理和查询，并且数据库也可以与其他的数据库进行合并或者扩展。

`conde`让你有能力在多重宇宙中计算并且观察到所有的可能性。
它逻辑上和其他语言的`if`或者`cond`是类似的分支结构。
但是所有的分支都会被执行，并且只有成功的路径会回馈给结果集。

最后，我们学习了如何创建我们自己的关系。
我们甚至还创建了一个递归关系。
这些内容看起来好像不多，但是已经能够让你构建一些自己的东西了。

### 轮到你了

是时候让你用core.logic来独立完成一些练习了。
别担心，我们会从一些简单的开始。

#### 查看... 

* core.logic的官方主页

* David Nolen，Dan Friedman或William Byrd的关于core.logic或者miniKanren的精彩视频

* core.logic的基本介绍

* 一些其他用core.logic的项目

#### 练习（简单）

* 尝试执行一个有两个`membero`目标并且`q`都是其第一个参数的逻辑程序。
当2个集合里有相同的元素时会发生什么？

* `appendo`是core.logic内嵌的功能，可以用来合并2个列表。
模仿`membero`的例子写几个逻辑程序来感受它是怎么工作的。
一定要试试将`q`放在3个不同参数位置上，来看看不同的结果。

* 创建2个数据库关系：
`languageo`和`systemo`，并且根据平时工作时的分类来添加相关的因子。

#### 练习（一般）

* 用`conde`创建一个关系`scientisto`，当对于任意的男性和女性时，返回成功。

* 写一个逻辑程序来找出所有获得过图灵奖的科学家。

#### 练习（困难）

* 用家族树数据库以及2个关系`childo`和`spouseso`来构建一个基因图谱。
然后再写出几个可以获得家族树的关系，例如：`ancestoro`、`descendanto`或者`cousino`。

* 实现一个与简单练习里提到过的内嵌关系`appendo`具有相同功能的`extendo`。

## 第二天：混合逻辑与函数
### 模式，那里都是模式
### 用上散列图
### 另一种判定
### 对David Nolen的采访
### 第二天我们学到了什么
### 轮到你了
## 第三天：用逻辑来写故事
### 用有限域编程
### 神奇的故事
### 第三天我们学到了什么
### 轮到你了
## miniKanren的回顾
### 优势
### 劣势
### 写在最后
